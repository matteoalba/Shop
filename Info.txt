# ARCHITETTURA A 5 PROGETTI: SPIEGAZIONE DEI COMPONENTI

## WebApi

- **Funzione**: Espone i servizi tramite API REST al mondo esterno
- **Responsabilità**:
  - Definire endpoint HTTP (GET, POST, PUT, DELETE, ecc.)
  - Gestire richieste e risposte HTTP
  - Configurare middleware (autenticazione, CORS, ecc.)
  - Instradare le richieste al layer Business
  - Documentare API (tramite Swagger/OpenAPI)
- **Contenuti tipici**:
  - Controller
  - Middleware
  - Configurazione
  - Startup/Program.cs

## Business

- **Funzione**: Implementa la logica di business del servizio
- **Responsabilità**:
  - Orchestrare operazioni complesse
  - Implementare regole di business
  - Validare dati
  - Coordinare interazioni tra Repository e ClientHttp
  - Gestire transazioni
- **Contenuti tipici**:
  - Service classes
  - Manager classes
  - Validator classes
  - Domain logic

## Repository

- **Funzione**: Gestisce l'accesso ai dati persistenti
- **Responsabilità**:
  - Astrarre operazioni di database (CRUD)
  - Implementare query complesse
  - Mappare entità DB a oggetti domain
  - Gestire cache di dati (opzionale)
- **Contenuti tipici**:
  - Repository classes
  - DbContext
  - Entity configurations
  - Migrations

## ClientHttp

- **Funzione**: Gestisce la comunicazione sincrona con altri microservizi
- **Responsabilità**:
  - Effettuare chiamate HTTP verso altri servizi
  - Gestire serializzazione/deserializzazione
  - Implementare retry policy e circuit breaker
  - Gestire timeout e fallimenti
- **Contenuti tipici**:
  - HTTP client classes
  - Service interfaces
  - Retry policies

## Shared

- **Funzione**: Contiene classi e modelli condivisi utilizzati da tutti gli altri componenti
- **Responsabilità**:
  - Definire DTO (Data Transfer Objects)
  - Definire modelli di dominio
  - Fornire utilities comuni
  - Definire costanti ed enumerazioni
- **Contenuti tipici**:
  - DTO classes
  - Domain models
  - Constants
  - Enums
  - Extensions

## DbContext (Entity Framework Core)

- **Funzione**: Rappresenta la sessione con il database
- **Responsabilità**:
  - Tracciare cambiamenti delle entità
  - Eseguire query sul database
  - Convertire query LINQ in SQL
  - Configurare mapping tra classi e tabelle
  - Gestire relazioni tra entità
  - Applicare validazioni e regole a livello di database
- **Contenuti tipici**:
  - DbSet<T> properties (rappresentano tabelle)
  - OnModelCreating() (configura mappings)
  - Vincoli e relazioni tra tabelle

## Flusso Tipico in un Microservizio

1. **WebApi** riceve una richiesta HTTP
2. Il controller passa i dati al **Business** layer
3. **Business** applica la logica di dominio
4. **Business** chiama **Repository** per dati persistenti
5. **Business** può usare **ClientHttp** per chiamare altri servizi
6. **Repository** utilizza **DbContext** per accedere al database
7. I dati fluiscono in direzione opposta come risposta
8. **Shared** fornisce modelli e DTO usati in tutto il flusso

## Pattern SAGA in questo progetto

Il pattern SAGA consente di gestire transazioni distribuite tra microservizi, dove ogni servizio gestisce la propria transazione locale e comunica con gli altri servizi tramite messaggi.

- **OrderService**: Avvia la saga (transazione pivot)
  - Crea l'ordine
  - Comunica con PaymentService e StockService

- **PaymentService**:
  - Processa il pagamento
  - Comunica successo/fallimento all'OrderService

- **StockService**:
  - Verifica disponibilità prodotti
  - Riserva/rilascia stock

In caso di fallimento in qualsiasi fase, vengono attivate transazioni di compensazione per ripristinare lo stato consistente.




DBContext: Va ad interagire direttamente con il database e mantiene i dati aggiornati.
Repository: Utilizza il dbcontext e va ad utilizzare i dati del database.
Business: Decide cosa deve fare effettivamente l'applicazione, e può utilizzare le funzione create nel repository.
Shared: Sono le entità/classi utilizzabili da tutti.
WebApi: Controller per creare le API.
ClientHttp: Gestisce la comunicazione sincrona con gli altri microservizi.






Problemi:

- 1: In updateOrderAsync mi sono ritrovato nel problema in cui:
    Se includi un item con un ID esistente nella richiesta, viene aggiornato
    Se includi un item con ID = 0, viene creato un nuovo item
    Se non includi un item esistente, viene rimosso dall'ordine
Lasciandolo cosi il client deve conoscere e inviare tutti gli items, anche quelli che non intende modificare e aumenta il rischio 
di rimuovere items per errore.

- 2: Capire il delete nello stock.
- 3: Operazioni di compensazione
- 4: Implementazione kafka, metodo di polling, connessione, ascolto fisso dei topic, concorrenza.


TODO:
 - Fix a 
        2025-07-05 16:05:21 fail: ShopSaga.StockService.ClientHttp.StockHttp[0]
2025-07-05 16:05:21       Errore durante la chiamata HTTP per verificare disponibilità prodotto 550e8400-e29b-41d4-a716-446655440001
2025-07-05 16:05:21       System.Net.Http.HttpRequestException: Connection refused (localhost:5003)

Order:

Crea ordine (OrderService):
- Controllo dello stock su items (StockService):
  - C'è spazio? Si, riservo gli item e creo ordine (StockService, OrderService).
                No, errore item non sufficienti nello stock (StockService).

Update ordine (OrderService):
- Controllo dello stock su items (StockService):
  - Controllo se:
                - Item aggiunto? Controllo spazio (StockService).
                - Item eliminato? Togli la riserva agli item (StockService)
                - Item aggiornato? Controlla spazio (StockService)
  - Un errore da qualche parte, rollback di tutto (OrderService, StockService).

Delete ordine (OrderService):
- Controllo se è gia stato pagato o no (OrderService, PaymentService):
 - Se c'è un pagamento completato, non possiamo cancellare l'ordine (OrderService).
 - Non pagato, gli item messi in riserva devono venire rilasciati (StockService).


Payment:

Crea pagamento (PaymentService):
 - Controllo se esiste l'ordine (OrderService).
 - Controllo se è nello stato giusto, cioè deve essere solo in "StockConfirmed" o qualcosa del genere (OrderService).
 - Tutto questo esiste? Si, crea pagamento (PaymentService).
                        No, errore order non esistente (PaymentService).

Process payment (PaymentService):
  - Aggiorna order con stato "Completed" (OrderService), aggiorna lo stock con item status acquisiti (StockService).

Refund (PaymentService):
  - Ridai gli item allo stock (StockService) e cambi stato con refunded (OrderService).

Cancel payment (PaymentService):
  - Stato di order messo a "Cancelled" (OrderService). 
  - Ridai gli item allo stock (StockService).


Stock:

Conferma tutti gli stock reservation per un ordine (StockService):
 - Riservo tutti gli item (StockService).
 - Aggiorno lo stato dell'order a "StockConfirmed" (OrderService).

Cancellazione stock (StockService):
 - Rilascio gli items (StockService)
 - Cambio lo stato in order a StockCancelled (OrderService).